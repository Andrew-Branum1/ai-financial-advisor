# llm/advisor.py
import logging
import json

async def generate_report_async(performance_data: dict, plot_paths: dict) -> str:
    """
    Generates a financial performance report using the Gemini API.

    Args:
        performance_data (dict): A dictionary containing performance metrics for the RL agent and benchmarks.
        plot_paths (dict): A dictionary with paths to the generated plot images.

    Returns:
        str: A natural language report generated by the LLM.
    """
    logging.info("Generating LLM report from performance data...")

    # --- 1. Craft a Detailed Prompt ---
    # Convert the performance data dictionary to a clean string format for the prompt.
    performance_summary = ""
    for strategy, metrics in performance_data.items():
        performance_summary += f"--- {strategy} ---\n"
        for key, value in metrics.items():
            if isinstance(value, float):
                # Nicely format percentages and ratios
                if "return" in key.lower() or "volatility" in key.lower() or "drawdown" in key.lower():
                    performance_summary += f"{key.replace('_', ' ').title()}: {value:.2%}\n"
                elif "ratio" in key.lower():
                     performance_summary += f"{key.replace('_', ' ').title()}: {value:.3f}\n"
                else:
                    performance_summary += f"{key.replace('_', ' ').title()}: {value:,.2f}\n"
            else:
                performance_summary += f"{key.replace('_', ' ').title()}: {value}\n"
        performance_summary += "\n"

    prompt = f"""
    You are an expert financial analyst AI. Your task is to provide a clear, insightful, and professional investment performance report.

    You have been given the performance data for three strategies over the same evaluation period:
    1.  'RL Agent': An autonomous trading agent based on Deep Reinforcement Learning.
    2.  'SPY Benchmark': A simple Buy-and-Hold strategy for the S&P 500 ETF (SPY).
    3.  'Equal-Weight Benchmark': A portfolio that holds an equal weight in the assets traded by the RL agent.

    Here is the quantitative performance summary:
    {performance_summary}

    Based on the data above, please generate a comprehensive report with the following structure:

    **1. Executive Summary:**
    Start with a brief, high-level overview. State which strategy performed the best overall and why, considering both returns and risk.

    **2. Performance Analysis:**
    - **Returns:** Compare the Cumulative Return and Final Portfolio Value for all three strategies. Who was the winner in terms of raw growth?
    - **Risk-Adjusted Performance:** This is the most important section. Analyze the Sharpe Ratio and Calmar Ratio. A higher ratio is better. Explain which strategy delivered the best returns for the amount of risk taken. Use the Max Drawdown and Annualized Volatility to explain the "risk" part of the equation. For instance, did the RL Agent achieve its returns more smoothly than the benchmarks?
    - **Trading Efficiency:** Comment on the RL Agent's "Total Transaction Costs" and "Average Daily Turnover". A low turnover and low costs are desirable, as they indicate an efficient trading strategy that isn't churning the portfolio unnecessarily.

    **3. RL Agent's Strategy Deep Dive:**
    - Based on the metrics, infer the likely strategy of the RL agent. For example, if it has a lower volatility and lower max drawdown than the benchmarks but similar returns, it likely learned a successful risk-mitigation strategy. If it has high turnover, it learned a very active, high-frequency strategy.

    **4. Concluding Remarks and Recommendation:**
    Conclude the report with a final recommendation. Based purely on this data, which strategy would you recommend for an investor and why? Mention any caveats (e.g., "past performance is not indicative of future results").

    Please write in a clear, professional, and accessible tone.
    """

    # --- 2. Call the Gemini API ---
    try:
        chat_history = [{"role": "user", "parts": [{"text": prompt}]}]
        payload = {"contents": chat_history}
        api_key = "" # API key is handled by the execution environment
        api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={api_key}"

        # Using an HTTP client that supports async, e.g., aiohttp
        # For simplicity in this example, we'll use a synchronous-style fetch
        # In a real async app, you'd use `await session.post(...)`
        
        # NOTE: This part is pseudo-code for the fetch call.
        # In a real application, you'd use a library like `aiohttp` or `httpx`.
        # The logic here assumes a simple fetch is available.
        # This part will need to be implemented with a real async HTTP client.
        
        from js import fetch # In a Pyodide/browser environment
        response = await fetch(api_url, {
            "method": 'POST',
            "headers": {'Content-Type': 'application/json'},
            "body": json.dumps(payload)
        })
        
        result = await response.json()

        if result.get("candidates"):
            report_text = result["candidates"][0]["content"]["parts"][0]["text"]
            logging.info("LLM report generated successfully.")
            return report_text
        else:
            logging.error(f"LLM API Error: No candidates in response. Response: {result}")
            return "Error: Could not generate the report due to an API issue."

    except Exception as e:
        logging.error(f"An exception occurred while calling the LLM API: {e}", exc_info=True)
        return f"Error: Failed to generate report. Exception: {e}"

